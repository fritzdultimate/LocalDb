function isPlainObject(obj){return"[object Object]"===toString.call(obj)}function isPlainArray(obj){return"[object Array]"===toString.call(obj)}function isInArray(array,search){for(let i=0;i<array.length;i++)if(array[i]==search)return!0;return!1}function isAllObject(obj){for(let i=0;i<obj.length;i++)if(!isPlainObject(obj[i]))return!1;return!0}function isAllArray(array){for(let i=0;i<array.length;i++)if(!isPlainArray(array[i]))return!1;return!0}function to_lc(str){return Array.isArray(str)?str.map(el=>"number"==typeof el?el:el.toLowerCase()):"number"==typeof str?str:"string"==typeof str?str.toLowerCase():str}class LocalDb{constructor(dbName){this.$db=to_lc(dbName),localStorage.getItem(this.$db)||localStorage.setItem(this.$db,JSON.stringify({})),this.affected_rows,Object.defineProperty(this,"where",{value:function(where){return this.where_clause=to_lc(where),this}}),Object.defineProperty(this,"isEmpty",{value:function(){for(let key in this)if(this.hasOwnProperty(key))return!1;return!0}}),Object.defineProperty(this,"like",{value:function(column,like,wildcard){return this.wildcard=null==wildcard?"both":to_lc(wildcard),this.like_column=to_lc(column),this.like_search=to_lc(like),this}}),Object.defineProperty(Array.prototype,"getFirst",{value:function(){let db_object="string"==typeof this[0]?JSON.parse(this[0]):this;return db_object.hasOwnProperty("db")?db_object.results.length?db_object.results.splice(0,1):db_object.results:db_object.length?db_object.splice(0,1):db_object}}),Object.defineProperty(Array.prototype,"getLast",{value:function(){let db_object="string"==typeof this[0]?JSON.parse(this[0]):this;return db_object.hasOwnProperty("db")?db_object.results.length?db_object.results.splice(-1,1):db_object.results:db_object.length?db_object.splice(-1,1):db_object}}),Object.defineProperty(Array.prototype,"getAll",{value:function(){let db_object="string"==typeof this[0]?JSON.parse(this[0]):this;return db_object.hasOwnProperty("db")?db_object.results:db_object}}),Object.defineProperty(Array.prototype,"orderBy",{value:function(column,flag){flag=to_lc(flag=null==flag?"asc":flag);let db_object=JSON.parse(this[0]),order_column=db_object.db[column].values;if(!db_object.results.length)return db_object.results;if(!column)throw new Error("orderBy expexts atleast one argument!");if(!db_object.db.hasOwnProperty(to_lc(column)))throw new Error(`unknown column '${column}'`);if("asc"!=flag&&"desc"!=flag)throw new Error(`unsupported flag! '${flag}'`);column=to_lc(column);let sort_return_val_g="asc"==flag?1:-1,sort_return_val_l="desc"==flag?1:-1,mapped=order_column.map((el,i)=>({index:i,value:to_lc(el)}));mapped.sort((a,b)=>a.value>b.value?sort_return_val_g:a.value<b.value?sort_return_val_l:0);let result=mapped.map(el=>db_object.results[el.index]);return result=result.filter(el=>null!=el),result}})}from(table){if(!table)throw new Error("table() expects a table name.");if("string"!=typeof table)throw new Error("table's name must be a string.");let db=localStorage.getItem(this.$db);if(db=JSON.parse(db),this.tableName=to_lc(table),!db.hasOwnProperty(this.tableName))throw new Error(`unknown table name '${table}'`);return this}create(table,key,...column){if(!arguments.length)throw new Error("table() expects atleast three arguements, 'table name, primary key, and array of column names or a string of one column name!");if(arguments.length<3)throw new Error("table() expects atleast three arguements, 'table name, primary key, and array of object names or a single object");if(isPlainObject(arguments[1])||isPlainArray(arguments[1]))throw new Error("There is an error in your query: primary key is expected as the second argument!");if("string"!=typeof table)throw new Error("table's name must be a string!");if("string"!=typeof key)throw new Error("primary key's name must be a string!");let db=localStorage.getItem(this.$db);if(db=JSON.parse(db),this.tableName=table.toLowerCase(),db.hasOwnProperty(this.tableName))return this.tableName=void 0,!0;let attribute=1==column.length?column[0]:column,these=this;if(key=to_lc(key),db[this.tableName]={},isPlainObject(attribute)){if(!attribute.hasOwnProperty("name"))throw new Error("There is an error in your query => column name not present");if(!attribute.hasOwnProperty("type"))throw new Error("There is an error in your query => column type absent.");if(attribute.hasOwnProperty("type")&&!isInArray(["int","integer","string","boolean","object"],attribute.type))throw new Error(`There is an error in your query => the column type '${attribute.type}' is not supported.`);if(key!=to_lc(attribute.name))throw new Error(`There is an error in your query => the primary key ${key} does not match any column name!`);if(!isInArray(["int","integer"],to_lc(attribute.type)))throw new Error("There is an error in your query => a primary key must be of type 'int or integer'");{attribute.name=to_lc(attribute.name),db[this.tableName].key=to_lc(key),db[this.tableName].lastid=0;let defaultValue=attribute.hasOwnProperty("default")?attribute.default:null;attribute.default=defaultValue,attribute.value=[],db[this.tableName][to_lc(attribute.name)]=attribute,localStorage.setItem(this.$db,JSON.stringify(db))}return this.tableName=void 0,!0}if(isPlainArray(attribute)){let columnNames=[];for(let i=0;i<attribute.length;i++)columnNames.push(to_lc(attribute[i].name));if(!isInArray(columnNames,key))throw new Error(`There is an error in your query => the primary key ${key} does not match any column name!`);attribute.forEach((element,index)=>{if(db[this.tableName].hasOwnProperty(to_lc(element.name)))throw new Error(`There is an error in your query => column ${element.name} already exist!`);if(!isInArray(["int","integer","string","boolean","object"],to_lc(element.type)))throw new Error(`There is an error in your query => the column type '${element.type}' is not supported.`);if(!element.hasOwnProperty("name"))throw new Error("There is an error in your query => column name not present.");if(!element.hasOwnProperty("type"))throw new Error("There is an error in your query => column type absent.");if(key==to_lc(element.name)&&!isInArray(["int","integer"],to_lc(element.type)))throw new Error("There is an error in your query => a primary key must be of type 'int or integer'");{to_lc(element.name)==key&&(db[this.tableName].key=key),element.name=to_lc(element.name);let defaultValue=element.hasOwnProperty("default")?element.default:null;element.default=defaultValue,element.values=[],db[this.tableName][to_lc(element.name)]=element}})}return db[this.tableName].lastid=0,localStorage.setItem(this.$db,JSON.stringify(db)),this.tableName=void 0,!0}insert(columnNames,values){if(!arguments.length)throw new Error("There is an error in your query => 'insert()' expects atleast two arguments, zero given.");if(arguments.length<2)throw new Error("insert() expects atleast two arguements, an array of column and an array of values'");if(!isAllArray([columnNames,values]))throw new Error("column names and values must be an array");if(null==this.tableName)throw new Error("table name not set, a call to 'from()' is expected");let db=localStorage.getItem(this.$db);db=JSON.parse(db);let key=db[this.tableName].key,these=this,lastid=db[this.tableName].lastid;if(columnNames.length!=values.length)throw new Error("column names must match number of values specified");if(!columnNames.length||!values.length)throw new Error("column names or values cannot be empty!");columnNames.forEach((el,i,a)=>{if(el=to_lc(el),!db[this.tableName].hasOwnProperty(el))throw new Error(`invalid column name '${el}'`);{let columnType=db[this.tableName][el].type,type=isInArray(["int","integer"],columnType)?"number":columnType;if(typeof values[i]!=type)throw new Error(`column type '${type}' does not match value type '${typeof values[i]}'`);if(el==key)throw new Error("you can't insert into a primary key");db[this.tableName][el].values.push(values[i])}a.length==i+1&&db[this.tableName][key].values.push(lastid)});for(let prop in db[this.tableName])if(isPlainObject(db[this.tableName][prop])&&!isInArray(to_lc([...columnNames,key]),prop)){let type=db[this.tableName][prop].type;if("object"==typeof db[this.tableName][prop].default&&(type=db[this.tableName][prop].type,type=isInArray(["int","integer"],type)?"number":type),type=isInArray(["int","integer"],type)?"number":type,typeof db[this.tableName][prop].default!=type&&null!=db[this.tableName][prop].default)throw new Error("Default value type must match your column type hint!");let defaultValue=db[this.tableName][prop].default;db[this.tableName][prop].values.push(defaultValue)}lastid++,db[this.tableName].lastid=lastid,localStorage.setItem(this.$db,JSON.stringify(db)),this.tableName=void 0}update(columnNames,values){if(this.affected_rows=0,!arguments.length)throw new Error("There is an error in your query => 'update()' expects atleast two arguments, zero given.");if(arguments.length<2)throw new Error("update() expects atleast three arguements, an array of column and an array of values'");if(!isAllArray([columnNames,values]))throw new Error("column names and values must be an array");if(null==this.tableName)throw new Error("table name not set, a call to 'from()' is expected");let db=localStorage.getItem(this.$db);db=JSON.parse(db);let columns=db[this.tableName];columnNames=to_lc(columnNames);let these=this;if(columnNames.length!=values.length)throw new Error("column names must match number of values specified");if(!columnNames.length||!values.length)throw new Error("column names or values cannot be empty!");if(!this.where_clause){if(!this.like_column)return columnNames.forEach((el,inx)=>{let columnType=db[this.tableName][el].type,type=isInArray(["int","integer"],columnType)?"number":columnType;if(!db[this.tableName].hasOwnProperty(el))throw new Error(`unknown column name '${el}`);if(typeof values[inx]!=type)throw new Error(`value '${values[inx]}' does not match column type '${db[this.tableName][el].type}'`);db[this.tableName][el].values.forEach((e,i)=>{db[this.tableName][el].values[i]=values[inx]}),this.affected_rows=db[this.tableName][el].values.length}),console.warn("Updating a table without a where clause will update every row of the matched column with the provided value!"),localStorage.setItem(this.$db,JSON.stringify(db)),this.tableName=void 0,!0;if(!db[this.tableName].hasOwnProperty(this.like_column))throw new Error(`search column '${like_column}' does not exist in your table!`);{let updateIndex=[];db[this.tableName][this.like_column].values.forEach((el,ind)=>{if("left"==this.wildcard)`${to_lc(el)}`.startsWith(this.like_search)&&updateIndex.push(ind);else if("right"==this.wildcard)`${to_lc(el)}`.endsWith(this.like_search)&&updateIndex.push(ind);else{if("both"!=this.wildcard)throw new Error(`invalid wildcard, expects either 'left, right or both', '${this.wildcard}' provided!`);`${to_lc(el)}`.startsWith(this.like_search)&&`${el}`.endsWith(this.like_search)&&updateIndex.push(ind)}}),this.affected_rows=updateIndex.length,columnNames.forEach((el,inx)=>{if(!db[this.tableName].hasOwnProperty(el))throw new Error(` unknown column name '${el}'`);updateIndex.forEach((elem,ind)=>{db[this.tableName][el].values[elem]=values[inx]})})}return this.like_column=void 0,this.tableName=void 0,!!this.affected_rows&&(localStorage.setItem(this.$db,JSON.stringify(db)),!0)}if(!this.like_column){if(!this.where_clause.length)throw new Error("invalid where clause!");if(!isPlainArray(this.where_clause))throw new Error("where clause expects an array!");if(this.where_clause.length<2)throw new Error("'where expects atleast two arguments!'");{let col=this.where_clause[0],match_value=this.where_clause[2],operator=this.where_clause[1];if(2==this.where_clause.length){operator="";let __char=[this.where_clause[1][0],this.where_clause[1][1]];if(match_value=`${this.where_clause[1]}`.split(""),!db[this.tableName].hasOwnProperty(col))throw new Error(`unknown column in your where clause! ${col}`);let op=0;for(;op<3;)isInArray(["!",">","<","="],__char[op])?(operator+=__char[op],match_value.splice(0,1),op++):op++;match_value=match_value.join(""),operator=""==operator?"==":operator,operator="="==operator?"==":operator}match_value=to_lc(match_value);let updateIndex=[];db[this.tableName][to_lc(col)].values.forEach((el,ind)=>{eval("el"+operator+"match_value")&&updateIndex.push(ind)}),this.affected_rows=updateIndex.length,columnNames.forEach((elem,inx)=>{if(!db[this.tableName].hasOwnProperty(elem))throw new Error("invalid column name");{let columnType=columns[elem].type,type=isInArray(["int","integer"],columnType)?"number":columnType;if(typeof values[inx]!=type)throw new Error("column type does not match value type");if(elem==db[this.tableName].key)throw new Error("updating a primary key failed");db[this.tableName][elem].values.forEach((e,i)=>{updateIndex.forEach((el,ind)=>{el==i&&(db[this.tableName][elem].values[el]=values[inx])})})}})}return this.where_clause=void 0,this.tableName=void 0,!!this.affected_rows&&(localStorage.setItem(this.$db,JSON.stringify(db)),!0)}}delete(table){if(this.affected_rows=0,null==this.tableName)throw new Error("table name not set, a call to 'from()' is expected");let db=localStorage.getItem(this.$db);db=JSON.parse(db);let these=this;if(this.where_clause){if(!this.like_column){if(!this.where_clause.length)throw new Error("invalid where clause!");if(!isPlainArray(this.where_clause))throw new Error("where clause expects an array!");if(this.where_clause.length<2)throw new Error("'where expects atleast two arguments!'");{let col=this.where_clause[0],match_value=this.where_clause[2],operator=this.where_clause[1];if(2==this.where_clause.length){operator="";let __char=[this.where_clause[1][0],this.where_clause[1][1]];if(match_value=`${this.where_clause[1]}`.split(""),!db[this.tableName].hasOwnProperty(col))throw new Error("unknown column in your where clause!");let op=0;for(;op<3;)isInArray(["!",">","<","="],__char[op])?(operator+=__char[op],match_value.splice(0,1),op++):op++;match_value=match_value.join(""),operator=""==operator?"==":operator,operator="="==operator?"==":operator}let deleteIndex=[];if(db[this.tableName][to_lc(col)].values.forEach((el,ind)=>{eval("el"+operator+"match_value")&&(deleteIndex.push(ind),console.log(el,operator,match_value))}),this.affected_rows=deleteIndex.length,deleteIndex.length){let d=[...deleteIndex];for(let prop in db[this.tableName])isPlainObject(db[this.tableName][prop])&&(d.forEach((el,ind)=>{ind>0&&(d=d.map(e=>e-1)),console.log(d),db[this.tableName][prop].values.splice(d[ind],1)}),d=[...deleteIndex])}}}return this.where_clause=void 0,this.tableName=void 0,!!this.affected_rows&&(localStorage.setItem(this.$db,JSON.stringify(db)),!0)}if(this.like_column){if(!db[this.tableName].hasOwnProperty(this.like_column))throw new Error(`search column '${this.like_column}' does not exist in your table!`);for(let prop in db[this.tableName])if(isPlainObject(db[this.tableName][prop])){let deleteIndex=[];if(prop==this.like_column)if(db[this.tableName][prop].values.forEach((el,ind)=>{"left"==this.wildcard&&`${el}`.startsWith(this.like_search)?deleteIndex.push(ind):"right"==this.wildcard&&`${el}`.endsWith(this.like_search)?deleteIndex.push(ind):"both"==this.wildcard&&`${el}`.startsWith(this.like_search)&&`${el}`.endsWith(this.like_search)&&deleteIndex.push(ind)}),this.affected_rows=deleteIndex.length,"left"==this.wildcard){if(deleteIndex.length){let d=[...deleteIndex];for(let elem in db[this.tableName])isPlainObject(db[this.tableName][elem])&&(d.forEach((el,ind)=>{ind>0&&(d=d.map(e=>e-1)),db[this.tableName][elem].values.splice(d[ind],1)}),d=[...deleteIndex])}}else if("right"==this.wildcard){if(deleteIndex.length){let d=[...deleteIndex];for(let elem in db[this.tableName])isPlainObject(db[this.tableName][elem])&&(d.forEach((el,ind)=>{ind>0&&(d=d.map(e=>e-1)),db[this.tableName][elem].values.splice(d[ind],1)}),d=[...deleteIndex])}}else{if("both"!=this.wildcard)throw new Error(`invalid wildcard, expects either 'left, right or both', '${this.wildcard}' provided!`);if(deleteIndex.length){let d=[...deleteIndex];for(let elem in db[this.tableName])isPlainObject(db[this.tableName][elem])&&(d.forEach((el,ind)=>{ind>0&&(d=d.map(e=>e-1)),db[this.tableName][elem].values.splice(d[ind],1)}),d=[...deleteIndex])}}}return this.like_column=void 0,this.tableName=void 0,!!this.affected_rows&&(localStorage.setItem(this.$db,JSON.stringify(db)),!0)}for(let prop in db[this.tableName])isPlainObject(db[this.tableName][prop])&&(db[this.tableName][prop].values=[],this.affected_rows++);return console.warn("Deleting a table without a where clause will delete every row in the table!"),this.tableName=void 0,!!this.affected_rows&&(localStorage.setItem(this.$db,JSON.stringify(db)),!0)}select(columns){if(!arguments.length)throw new Error("There is an error in your query => 'select()' expects an array columns.");if(!isPlainArray(columns))throw new Error("second argument expects an array of column names");if(!columns.length)throw new Error("no column name present.");let db=localStorage.getItem(this.$db);db=JSON.parse(db);let these=this;if("*"==columns[0]&&1==columns.length){columns=[];for(let prop in db[this.tableName])isPlainObject(db[this.tableName][prop])&&columns.push(prop)}let result=[],obj,len=0,i=0;if(!this.where_clause&&!this.like_column){columns.forEach((el,ind)=>{if(!db[this.tableName].hasOwnProperty(el))throw new Error(`unknown column name! ${el}`);for(;len<db[this.tableName][el].values.length;)if(i)result[len][el]=db[this.tableName][el].values[len],len++;else{obj={};let item=db[this.tableName][el].values[len];obj[el]=item,result.push(obj),len++}len=0,i++});let object=db[this.tableName];return delete object.lastid,delete object.key,this.tableName=void 0,[JSON.stringify({db:object,results:result})]}if(this.where_clause){if(!this.where_clause.length)throw new Error("invalid where clause!");if(!isPlainArray(this.where_clause))throw new Error("where clause expects an array!");if(this.where_clause.length<2)throw new Error("'where expects atleast two arguments!'");{let col=this.where_clause[0],match_value=this.where_clause[2],operator=this.where_clause[1];if(2==this.where_clause.length){operator="";let __char=[this.where_clause[1][0],this.where_clause[1][1]];if(match_value=`${this.where_clause[1]}`.split(""),!db[this.tableName].hasOwnProperty(col))throw new Error(`unknown column in your where clause! ${col}`);let op=0;for(;op<3;)isInArray([">","<","=","!"],__char[op])?(operator+=__char[op],match_value.splice(0,1),op++):op++;match_value=match_value.join(""),operator=""==operator?"==":operator,operator="="==operator?"==":operator}let selectIndex=[];db[this.tableName][to_lc(col)].values.forEach((el,ind)=>{el=to_lc(el);let el1=JSON.stringify(el),el2=JSON.stringify(match_value);eval(`${el1}`+operator+`${el2}`)&&selectIndex.push(ind)}),selectIndex.length&&columns.forEach((el,ind)=>{if(!db[this.tableName].hasOwnProperty(el))throw new Error(`unknown column name! ${el}`);for(;len<selectIndex.length;)if(i)result[len][el]=db[this.tableName][el].values[selectIndex[len]],len++;else{obj={};let item=db[this.tableName][el].values[selectIndex[len]];obj[el]=item,result.push(obj),len++}len=0,i++})}let object=db[this.tableName];return delete object.lastid,delete object.key,this.tableName=void 0,[JSON.stringify({db:object,results:result})]}if(this.like_column){if(!db[this.tableName].hasOwnProperty(this.like_column))throw new Error(`search column '${this.like_column}' does not exist in your table!`);for(let prop in db[this.tableName])if(isPlainObject(db[this.tableName][prop])){let selectIndex=[];if(prop==this.like_column){if(db[this.tableName][prop].values.forEach((el,ind)=>{"left"==this.wildcard&&`${el}`.startsWith(this.like_search)?selectIndex.push(db[this.tableName][prop].values.indexOf(el)):"right"==this.wildcard&&`${el}`.endsWith(this.like_search)?selectIndex.push(db[this.tableName][prop].values.indexOf(el)):"both"==this.wildcard&&`${el}`.startsWith(this.like_search)&&`${el}`.endsWith(this.like_search)&&selectIndex.push(db[this.tableName][prop].values.indexOf(el))}),"left"==this.wildcard){if(selectIndex.length){columns.forEach((el,ind)=>{if(!db[this.tableName].hasOwnProperty(el))throw new Error(`unknown column name! ${el}`);for(;len<selectIndex.length;)if(i)result[len][el]=db[this.tableName][el].values[selectIndex[len]],len++;else{obj={};let item=db[this.tableName][el].values[selectIndex[len]];obj[el]=item,result.push(obj),len++}len=0,i++});let object=db[this.tableName];return delete object.lastid,delete object.key,this.tableName=void 0,this.like_column=void 0,[JSON.stringify({db:object,results:result})]}let object=db[this.tableName];return delete object.lastid,delete object.key,this.tableName=void 0,this.like_column=void 0,[JSON.stringify({db:object,results:result})]}if("right"==this.wildcard){if(selectIndex.length){columns.forEach((el,ind)=>{if(!db[this.tableName].hasOwnProperty(el))throw new Error(`unknown column name! ${el}`);for(;len<selectIndex.length;)if(i)result[len][el]=db[this.tableName][el].values[selectIndex[len]],len++;else{obj={};let item=db[this.tableName][el].values[selectIndex[len]];obj[el]=item,result.push(obj),len++}len=0,i++});let object=db[this.tableName];return delete object.lastid,delete object.key,this.tableName=void 0,this.like_column=void 0,[JSON.stringify({db:object,results:result})]}let object=db[this.tableName];return delete object.lastid,delete object.key,this.tableName=void 0,this.like_column=void 0,[JSON.stringify({db:object,results:result})]}if("both"==this.wildcard){if(selectIndex.length){columns.forEach((el,ind)=>{if(!db[this.tableName].hasOwnProperty(el))throw new Error(`unknown column name! ${el}`);for(;len<selectIndex.length;)if(i)result[len][el]=db[this.tableName][el].values[selectIndex[len]],len++;else{obj={};let item=db[this.tableName][el].values[selectIndex[len]];obj[el]=item,result.push(obj),len++}len=0,i++});let object=db[this.tableName];return delete object.lastid,delete object.key,this.tableName=void 0,this.like_column=void 0,[JSON.stringify({db:object,results:result})]}let object=db[this.tableName];return delete object.lastid,delete object.key,this.tableName=void 0,this.like_column=void 0,[JSON.stringify({db:object,results:result})]}throw new Error(`invalid wildcard, expects either 'left, right or both', '${this.wildcard}' provided!`)}}this.like_column=void 0;let object=db[this.tableName];return delete object.lastid,delete object.key,this.tableName=void 0,[JSON.stringify({db:object,results:result})]}}get dbObject(){return JSON.parse(localStorage.getItem(this.$db))}}